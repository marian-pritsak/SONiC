# SONiC+ Applications Extensions Infrastructure
## Motivation
The SONiC NOS was made with extendability in mind. This document focuses on making the process of extending SONiC as easy as possible.

The main building block of SONiC is Docker. We are going to leverage the existing Docker and Docker Hub infrastructure and build SONiC+ on top of it.

While Docker provides a tool for packaging an application and Docker Hub - for hosting it, it is not enough to just execute `docker pull` to make an application "look and feel" like a native SONiC application. SONiC+ aims at making the process of development and integration of 3-rd party applications with a native integration into SONiC. For that we need to provide SONiC+ with the hooks to connect every SONiC+ application with the SONiC native infrastructure, like access to CONIFG DB, SAI, CLI, REST APIs, logging, ISSU etc.
The next section provides a ilst of requirements for the SONiC+ infrastructure.

When the SONiC+ will become a part of SONiC, the application developer will not have to integrate every application into the SONiC codebase but maintain them separately. This follows all the popular Linux distributions that allow for installation of external applications.

This document while describing how SONiC+ will be implemented also provides reuirements and guidelines for SONiC+ application to follow, marked as **MUST** and **CAN** respectively.

![alt text](https://github.com/marian-pritsak/SONiC/blob/patch-1/doc/sonic_plus/SONiC%2B.jpg "Sonic+")
## Requirements
SONiC+ infrastructure must satisfy the requirements below to give the SONiC user the look and feel of the original SONiC image.
1. The application provider can build a SONiC+ docker without building SONiC image
2. User can download SONiC+ docker without building it
3. User can browse available SONiC+ docker
4. User can add a new SONiC+ docker repository
5. apt like utility to be provided in SONiC for managing SONiC+ dockers
6. CONFIG_DB integration - subscribe to CONFIG_DB
7. APPL_DB integration - write to APPLICATION_DB
8. ASIC_DB integration - SAI calls
9. Can provide a default configuration
10. Can start automatically after installation
11. Can be started automatically after a system reboot
12. Can perform a graceful shutdown/restart
13. Can restart upon config reload
14. Can write to SONiC log
15. Autogenerated CLI based on CONFIG_DB schema
16. Autogenerated REST API based on CONFIG_DB schema
17. Can verify a platform it's running on
18. Shares the SONiC network namespace
19. Must be built from the same base SONiC+ docker layer
20. Must support multiple versions for the same SONiC release

The rest of the document provides with a means of satisfying those requirements.

## Managing SONiC+ dockers
SONiC+ will provide a utility called `sonic_plus` that will provide a user with a unified way of managing the SONiC+ applications (req. 2, 3, 4, 5):
```
$ sonic-plus --help
Usage: sonic-plus [OPTIONS] COMMAND [ARGS]...

  SONiC+ management tool

Options:
  --help  Show this message and exit.

Commands:
  addrepo     Add SONiC+ application repository
  install     Install SONiC+ application
  remove      Remove SONiC+ application
  removerepo  Add SONiC+ application repository
  show        Show SONiC+ available, installed applications

$ sonic-plus show
NAME        REPO                      DESCRIPTION               STATUS
------      ------------------------  ------------------------  -------------
my_app1     my_org/my_app1            My application            Not installed
my_app2     my_org/my_app1            My other application      Installed
some_app3   some_org/some_app         Some 3-rd party app       Not installed
```

The user can add or remove the repositories of SONiC+ applications, install and uninstall them, and list what's available/installed.
## SONiC SDK docker
The process of providing a new SONiC+ application consists of two steps - building a SONiC+ docker and downloading and using it on a switch.
This section focuses on the first step.

SONiC has a set of libraries that provide us with tools for accessing configuration, calling SAI APIs, and logging (req. 6, 7, 8, 14).
Provided that there is a full blown development environment - sonic-buildimage, it is easy to build a new application that will use those libraries.
But there is no need to actually spend time and build the whole image just to compile a SONiC+ application (req. 1).

For that purpose, a SONiC SDK docker image is to be provided along with the SONiC image to give everyone an ability to set up a SONiC development environment in just seconds.
The required actions will be to use the SDK image as a base for the future SONiC+ docker's Dockerfile.
```
FROM sonic/sonic-sdk:201910
```

The sonic-sdk docker has all the swss SDK libraries like:
* swss common
* sairedis
* etc.

Along with their -dev packages, and build packages like gcc, make, autotools etc.

## CONFIG_DB schema
Every SONiC+ application **MUST** provide a valid CONFIG_DB schema file `/schema.json` within it's Docker image (req. 6).
Below is the table of the fields that are used to describe the CONFIG_DB schema:

Path | Type | Description | Value restriction
--- | --- | --- | ---
/name | string | Name of the application | Lowercase letters, numbers and underscores
/description | string | User friendly description
/keys | array | Array of keys' descriptions
/keys/{{index}}/name | string | Name of the application | Lowercase letters, numbers and underscores, must start with "{{/name.upper()}}_"
/keys/{{index}}/description | string | User friendly description
/keys/{{index}}/fields | array | Array of fields' descriptions
/keys/{{index}}/fields/{{index}}/name | string | Name of the field | Uppercase letters, numbers and underscores
/keys/{{index}}/fields/{{index}}/description | string | User friendly description
/keys/{{index}}/fields/{{index}}/type | string | Type of the field | One of string,int,intrange,choice
/keys/{{index}}/fields/{{index}}/optional | bool | Indicates if the field is optional | True or False, optional - default is False
/keys/{{index}}/fields/{{index}}/intmin | int | Min integer value | Valid only if /keys/{{index}}/fields/{{index}}/type is "intrange"
/keys/{{index}}/fields/{{index}}/intmax | int | Max integer value | Valid only if /keys/{{index}}/fields/{{index}}/type is "intrange"
/keys/{{index}}/fields/{{index}}/choice_list | array | Array of choices | Array items are strings, valid only if /keys/{{index}}/fields/{{index}}/type is "choice"
/keys/global_fields | array | Global configuration fields
/global_fields/{{index}}/name | string | Name of the field | Lowercase letters, numbers and underscores
/global_fields/{{index}}/description | string | User friendly description
/global_fields/{{index}}/type | string | Type of the field | One of string,int,intrange,choice
/global_fields/{{index}}/optional | bool | Indicates if the field is optional | True or False, optional - default is False
/global_fields/{{index}}/intmin | int | Min integer value | Valid only if /global_fields/{{index}}/type is "intrange"
/global_fields/{{index}}/intmax | int | Max integer value | Valid only if /global_fields/{{index}}/type is "intrange"
/global_fields/{{index}}/choice_list | array | Array of choices | Array items are strings, valid only if /global_fields/{{index}}/type is "choice"

**TODO:** More fields types

For example, below is the schema for an application that attaches a counter to a route, periodically polls those flow counters, and sends the values to some proprietary collector:
```
{
    "name": "route_hit_report",
    "description": "Attach counters to IPv4 routes and stream them to collectors",
    "global_fields": [
        {
            "name": "enable",
            "description": "Enable/disable the application",
            "type": "bool"
        },
        {
            "name": "poll_interval",
            "description": "Polling interval in seconds",
            "type": "int"
        }
    ],
    "keys": [
        {
            "name": "ROUTE_HIT_REPORT_COUNTER",
            "description": "Route counter",
            "fields": [
                {
                    "name": "prefix",
                    "description": "Route prefix to attach to",
                    "type": "ipv4prefix"
                }
            ]
        },
        {
            "name": "ROUTE_HIT_REPORT_COLLECTOR",
            "description": "Remote collector configuration",
            "fields": [
                {
                    "name": "address",
                    "description": "Collector's IP address",
                    "type": "ipv4address"
                },
                {
                    "name": "port",
                    "description": "Collector's port",
                    "type": "intrange",
                    "intmin": "1024",
                    "intmax": "65000"
                }
            ]
        }
    ]
}
```

SONiC+ application can provide a default configuration. It MUST be located in the Docker image path /default_config.json and will be validated against the provided schema. For example, The artifitial application above could have the following defaults:
```
{
    "ROUTE_HIT_REPORT": {
        "global": {
            "enable": "False",
            "polling_interval": "5"
        }
    },
    "ROUTE_HIT_REPORT_COUNTER": {
        "counter1" : {
            "prefix": "1.1.0.0/16"
        },
        "counter1" : {
            "prefix": "1.2.0.0/16"
        }
    },
    ROUTE_HIT_REPORT_COLLECTOR": {
        "my_collector" : {
            "address": "10.10.10.10",
            "port": "101010"
        }
    }
}
```

## Systemd integration
Upon installation of SONiC+ application, a systemd service will be generated and enabled.
## Shared resources
SONiC+ infrastructure will provide every SONiC+ application docker with the following resources from the image:
* Base image network namespace (req. 6, 7, 8)
* Redis DB socket file (req. 18)
* Base image syslog access (req. 14)
## Shutdown and reloads
SONiC can perform different types of application shutdown and reloaad:
* `config reload` command
* `reboot` command
* `fast-reboot` command

Every such valid scenario of the application reload will notifyevery SONiC+ application and wait a reasonable amount of time for their shutdown.
**TODO** Notification mechanism
## Autogenerated configuration interfaces
TBD
## Entrypoint
TBD
## Versioning
The SONiC+ application infrastructure is intended mainly for the general availability releases of SONiC. For every SONiC release, there will be a corresponding SONiC SDK Docker image.

For example, the SONiC release 201910 will have a SONiC SDK Docker image with a tag 201910, so the developer can build an application docker from it:
```
FROM sonic/sonic-sdk:201910
```
Thanks to the Docker infrastructure, the SONiC+ application developer can maintain multiple versions of the application for the same release. The following rules **MUST** be followed with regards to SONiC+ application versions:
* Docker tag for the application release MUST start with the SONiC release version.
* Latest version of the application for a given SONiC release **MUST** be also tagged as <SONiC relases>-latest to be used as default version if none is specified.

For example, user can download the latest version of the application in the release 201910 using command `sonic-plus install my_app` which will pull the image `my_organization/my_app:201910-latest`, or be more specific and type `sonic-plus install my_app --version 2` which will pull the image `my_organization/my_app:201910-2`.
