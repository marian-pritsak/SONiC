# SONiC+ Applications Extensions Infrastructure
## Table of Contents
[Revision Table](#revision-table)

[Motivation](#motivation)

[Requirements](#requirements)

[Managing SONiC+ Applications](#managing-sonic-applications)

[SONiC SDK Docker](#sonic-sdk-docker)

[CONFIG_DB schema](#config_db-schema)

[Autogenerated configuration interfaces](#autogenerated-configuration-interfaces)

[Systemd Integration](#systemd-integration)

[Shared Resources](#shared-resources)

[Shutdown and Reloads](#shutdown-and-reloads)

[Entrypoint](#entrypoint)

[Sharing State With Orchagent](#sharing-state-with-orchagent)

## Revision Table

| Rev |     Date    |       Author       | Change Description                |
|:---:|:-----------:|:------------------:|-----------------------------------|
|1.0|10/7/2019|Marian Pritsak|Initial Version

## Motivation
The SONiC NOS was made with extendability in mind. This document focuses on making the process of extending SONiC as easy as possible.

The main building block of SONiC is Docker. We are going to leverage the existing Docker and Docker Hub infrastructure and build SONiC+ on top of it.

While Docker provides a tool for packaging an application and Docker Hub - for hosting it, it is not enough to just execute `docker pull` to make an application "look and feel" like a native SONiC application. SONiC+ aims at making the process of development and integration of 3-rd party applications with a native integration into SONiC. For that we need to provide SONiC+ with the hooks to connect every SONiC+ application with the SONiC native infrastructure, like access to CONIFG DB, SAI, CLI, REST APIs, logging, ISSU etc.
The next section provides a ilst of requirements for the SONiC+ infrastructure.

When the SONiC+ will become a part of SONiC, the application developer will not have to integrate every application into the SONiC codebase but maintain them separately. This follows all the popular Linux distributions that allow for installation of external applications.

This document while describing how SONiC+ will be implemented also provides reuirements and guidelines for SONiC+ application to follow, marked as **MUST** and **CAN** respectively.

![alt text](https://github.com/marian-pritsak/SONiC/blob/patch-1/doc/sonic_plus/SONiC%2B.jpg "Sonic+")
## Requirements
SONiC+ infrastructure must satisfy the requirements below to give the SONiC user the look and feel of the original SONiC image.
1. The application provider can build a SONiC+ docker without building SONiC image
2. User can download SONiC+ docker without building it
3. User can browse available SONiC+ docker
4. User can add a new SONiC+ docker repository
5. apt like utility to be provided in SONiC for managing SONiC+ dockers
6. CONFIG_DB integration - subscribe to CONFIG_DB
7. APPL_DB integration - write to APPLICATION_DB
8. ASIC_DB integration - SAI calls
9. Can provide a default configuration
10. Can start automatically after installation
11. Can be started automatically after a system reboot
12. Can perform a graceful shutdown/restart
13. Can restart upon config reload
14. Can write to SONiC log
15. Autogenerated CLI based on CONFIG_DB schema
16. Autogenerated REST API based on CONFIG_DB schema
17. Can verify a platform it's running on
18. Shares the SONiC network namespace
19. Must be built from the same base SONiC+ docker layer
20. Must support multiple versions for the same SONiC release

The rest of the document provides with a means of satisfying those requirements.

## Managing SONiC+ Applications
SONiC+ will provide a utility called `sonic_plus` that will provide a user with a unified way of managing the SONiC+ applications (req. 2, 3, 4, 5):
```
$ sonic-plus --help
Usage: sonic-plus [OPTIONS] COMMAND [ARGS]...

  SONiC+ management tool

Options:
  --help  Show this message and exit.

Commands:
  addrepo     Add SONiC+ application repository
  install     Install SONiC+ application
  remove      Remove SONiC+ application
  removerepo  Add SONiC+ application repository
  show        Show SONiC+ available, installed applications

$ sonic-plus show
NAME        REPO                      DESCRIPTION               STATUS
------      ------------------------  ------------------------  -------------
my_app1     my_org/my_app1            My application            Not installed
my_app2     my_org/my_app1            My other application      Installed
some_app3   some_org/some_app         Some 3-rd party app       Not installed
```

The user can add or remove the repositories of SONiC+ applications, install and uninstall them, and list what's available/installed.

## SONiC SDK Docker
The process of providing a new SONiC+ application consists of two steps - building a SONiC+ docker and downloading and using it on a switch.
This section focuses on the first step.

SONiC has a set of libraries that provide us with tools for accessing configuration, calling SAI APIs, and logging (req. 6, 7, 8, 14).
Provided that there is a full blown development environment - sonic-buildimage, it is easy to build a new application that will use those libraries.
But there is no need to actually spend time and build the whole image just to compile a SONiC+ application (req. 1).

For that purpose, a SONiC SDK docker image is to be provided along with the SONiC image to give everyone an ability to set up a SONiC development environment in just seconds.
The required actions will be to use the SDK image as a base for the future SONiC+ docker's Dockerfile.
```
FROM sonic/sonic-sdk:201910
```

The sonic-sdk docker has all the swss SDK libraries like:
* swss common
* sairedis
* etc.

Along with their -dev packages, and build packages like gcc, make, autotools etc.

## CONFIG_DB Schema
Every SONiC+ application **MUST** provide a valid CONFIG_DB schema file `/schema.json` within it's Docker image (req. 6).
Below is the table of the fields that are used to describe the CONFIG_DB schema:

Path | Type | Description | Value restriction
--- | --- | --- | ---
/name | string | Name of the application | Lowercase letters, numbers and underscores
/description | string | User friendly description
/keys | array | Array of keys' descriptions
/keys/{{index}}/name | string | Name of the application | Lowercase letters, numbers and underscores, must start with "{{/name.upper()}}_"
/keys/{{index}}/description | string | User friendly description
/keys/{{index}}/fields | array | Array of fields' descriptions
/keys/{{index}}/fields/{{index}}/name | string | Name of the field | Uppercase letters, numbers and underscores
/keys/{{index}}/fields/{{index}}/description | string | User friendly description
/keys/{{index}}/fields/{{index}}/type | string | Type of the field | One of string,int,intrange,choice
/keys/{{index}}/fields/{{index}}/optional | bool | Indicates if the field is optional | True or False, optional - default is False
/keys/{{index}}/fields/{{index}}/intmin | int | Min integer value | Valid only if /keys/{{index}}/fields/{{index}}/type is "intrange"
/keys/{{index}}/fields/{{index}}/intmax | int | Max integer value | Valid only if /keys/{{index}}/fields/{{index}}/type is "intrange"
/keys/{{index}}/fields/{{index}}/choice_list | array | Array of choices | Array items are strings, valid only if /keys/{{index}}/fields/{{index}}/type is "choice"
/keys/global_fields | array | Global configuration fields
/global_fields/{{index}}/name | string | Name of the field | Lowercase letters, numbers and underscores
/global_fields/{{index}}/description | string | User friendly description
/global_fields/{{index}}/type | string | Type of the field | One of string,int,intrange,choice
/global_fields/{{index}}/optional | bool | Indicates if the field is optional | True or False, optional - default is False
/global_fields/{{index}}/intmin | int | Min integer value | Valid only if /global_fields/{{index}}/type is "intrange"
/global_fields/{{index}}/intmax | int | Max integer value | Valid only if /global_fields/{{index}}/type is "intrange"
/global_fields/{{index}}/choice_list | array | Array of choices | Array items are strings, valid only if /global_fields/{{index}}/type is "choice"

**TODO:** More fields types

For example, below is the schema for an application that attaches a counter to a route, periodically polls those flow counters, and sends the values to some proprietary collector:
```
{
    "name": "route_hit_report",
    "description": "Attach counters to IPv4 routes and stream them to collectors",
    "global_fields": [
        {
            "name": "enable",
            "description": "Enable/disable the application",
            "type": "bool"
        },
        {
            "name": "poll_interval",
            "description": "Polling interval in seconds",
            "type": "int"
        }
    ],
    "keys": [
        {
            "name": "ROUTE_HIT_REPORT_COUNTER",
            "description": "Route counter",
            "fields": [
                {
                    "name": "prefix",
                    "description": "Route prefix to attach to",
                    "type": "ipv4prefix"
                }
            ]
        },
        {
            "name": "ROUTE_HIT_REPORT_COLLECTOR",
            "description": "Remote collector configuration",
            "fields": [
                {
                    "name": "address",
                    "description": "Collector's IP address",
                    "type": "ipv4address"
                },
                {
                    "name": "port",
                    "description": "Collector's port",
                    "type": "intrange",
                    "intmin": "1024",
                    "intmax": "65000"
                }
            ]
        }
    ]
}
```

SONiC+ application **CAN** provide a default configuration. It **MUST** be located in the Docker image path /default_config.json and will be validated against the provided schema. For example, The artifitial application above could have the following defaults:
```
{
    "ROUTE_HIT_REPORT": {
        "global": {
            "enable": "False",
            "polling_interval": "5"
        }
    },
    "ROUTE_HIT_REPORT_COUNTER": {
        "counter1" : {
            "prefix": "1.1.0.0/16"
        },
        "counter1" : {
            "prefix": "1.2.0.0/16"
        }
    },
    ROUTE_HIT_REPORT_COLLECTOR": {
        "my_collector" : {
            "address": "10.10.10.10",
            "port": "101010"
        }
    }
}
```

## Autogenerated Configuration Interfaces
The schema described above the the only mean of talinkng to/configuring the SONiC+ appilcation. It is also used to generate other types of UI to make the process of interacting with the application easier and faster.

For every SONiC+ application, other interfaces are generated automatically based on the schema file provided. For example, the application from the previous section will have the following CLI commands available:

```
$ route_hit_report enable [True/False]
$ route_hit_report poll_interval [INTERVAL]
$ route_hit_report create counter [NAME] [PREFIX]
$ route_hit_report create collector [NAME] [ADDRESS] [PORT]
$ route_hit_report remove counter [NAME]
$ route_hit_report remove collector [NAME]
$ route_hit_report show counter
$ route_hit_report show collector
```

## Systemd Integration
Upon installation of SONiC+ application, a systemd service will be generated and enabled.
## Shared Resources
SONiC+ infrastructure will provide every SONiC+ application docker with the following resources from the image:
* Base image network namespace (req. 6, 7, 8)
* Redis DB socket file (req. 18)
* Base image syslog access (req. 14)
## Shutdown and Reloads
SONiC can perform different types of application shutdown and reloaad:
* `config reload` command
* `reboot` command
* `fast-reboot` command

Every such valid scenario of the application reload will notifyevery SONiC+ application and wait a reasonable amount of time for their shutdown.

**TODO** Notification mechanism
## Entrypoint
SONiC+ application will be managed by SONiC supervisor, therefore it **MUST** provide a list of critical applications in /processes.json, their arguments, and optional pre- and post-start commands to be executed within a container.

Path | Type | Description
--- | --- | ---
/prestart | array | List of pre-start commands to execute
/prestart/{{index}}/command | string | Command string
/processes | array | List processes for supervisor
/processes/{{index}}/path | string | Binary path
/processes/{{index}}/arguments | string | Process arguments
/poststart | array | List of post-start commands to execute
/poststart/{{index}}/command | string | Command string

For example:

```
{
    "prestart": [
        "/usr/bin/command1",
        "/usr/bin/command2"
    ],
    "processes": [
        {
            "path": "/usr/bin/command3",
            "arguments": "--arg1 arg1"
        },
    ],
    "poststart": [
        "/usr/bin/command3",
        "/usr/bin/command4"
    ]
}
```

SONiC+ will take care of generating all the `supervisord` files and start a container with the appropriate entrypoint to make `supervisord` manage the processes execution.

## Sharing State With Orchagent
To be able to make SAI calls, it is not enough just to have an access to the ASIC DB via libsairedis. The orchagent-like application within a SONiC+ container also needs to share a state with the orchagent itself and possibly with other applications. For example, the application needs to create an ACL rule that will mirror some packets to the collector. The schema for the mirror session is already defined and mirror sessions are created by the orchagent. Next, it needs to bind the ACL group to some ports, which are again created by the orchagent.

![alt text](https://github.com/marian-pritsak/SONiC/blob/patch-1/doc/sonic_plus/SONiC%2B%20orch.jpg "Sonic+ orch")

The solution to the problem is to move the orchagent state out of the process. But the challenge is how to make it automatically with minimal changes to the orchagent code. The proposed mechanism is to introduce a new mapping in the ASIC DB called CLIENT_COOKIE_TO_OID_MAP. The libsairedis API will be extended with a function `set_client_cookie(string cookie)` that will make libsairedis add a new entry of the format `<cookie>|<SAI OID>` into a CLIENT_COOKIE_TO_OID_MAP. In the orchagent the handling of all changes in the APP_DB `while (it != consumer.m_toSync.end()) {` will start with `set_client_cookie(kfvKey(it->second)` which will fill CLIENT_COOKIE_TO_OID_MAP with entries `APP_DB_TABLE:KEY|SAI_OID` upon each SAI object created within this context. Every handler will reset the value of the cookie to the APP_DB key that it is processing at the moment.

![alt text](https://github.com/marian-pritsak/SONiC/blob/patch-1/doc/sonic_plus/SONiC%2B%20shared.jpg "Sonic+ orch")

## Versioning
The SONiC+ application infrastructure is intended mainly for the general availability releases of SONiC. For every SONiC release, there will be a corresponding SONiC SDK Docker image.

For example, the SONiC release 201910 will have a SONiC SDK Docker image with a tag 201910, so the developer **MUST** build an application docker from it:
```
FROM sonic/sonic-sdk:201910
```
Thanks to the Docker infrastructure, the SONiC+ application developer **CAN** maintain multiple versions of the application for the same release. The following rules **MUST** be followed with regards to SONiC+ application versions:
* Docker tag for the application release **MUST** start with the SONiC release version.
* Latest version of the application for a given SONiC release **MUST** be also tagged as <SONiC relases>-latest to be used as default version if none is specified.

For example, user can download the latest version of the application in the release 201910 using command `sonic-plus install my_app` which will pull the image `my_organization/my_app:201910-latest`, or be more specific and type `sonic-plus install my_app --version 2` which will pull the image `my_organization/my_app:201910-2`.
